"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateContainerName = exports.removeQuotationFromListBlobEtag = exports.deserializePageBlobRangeHeader = exports.deserializeRangeHeader = exports.streamToLocalFile = exports.checkApiVersion = void 0;
const tslib_1 = require("tslib");
const fs_1 = require("fs");
const StorageErrorFactory_1 = tslib_1.__importDefault(require("../errors/StorageErrorFactory"));
function checkApiVersion(inputApiVersion, validApiVersions, requestId) {
    if (!validApiVersions.includes(inputApiVersion)) {
        throw StorageErrorFactory_1.default.getInvalidHeaderValue(requestId, {
            HeaderName: "x-ms-version",
            HeaderValue: inputApiVersion
        });
    }
}
exports.checkApiVersion = checkApiVersion;
async function streamToLocalFile(stream, path) {
    return new Promise((resolve, reject) => {
        const writeStream = fs_1.createWriteStream(path);
        stream
            .on("error", reject)
            // .on("end", resolve)
            .pipe(writeStream)
            .on("close", resolve)
            .on("error", reject);
    });
}
exports.streamToLocalFile = streamToLocalFile;
/**
 * Default range value [0, Infinite] will be returned if all parameters not provided.
 *
 * @export
 * @param {string} [rangeHeaderValue]
 * @param {string} [xMsRangeHeaderValue]
 * @returns {[number, number]}
 */
function deserializeRangeHeader(rangeHeaderValue, xMsRangeHeaderValue) {
    const range = xMsRangeHeaderValue || rangeHeaderValue;
    if (!range) {
        return [0, Infinity];
    }
    let parts = range.split("=");
    if (parts === undefined || parts.length !== 2) {
        throw new RangeError(`deserializeRangeHeader: raw range value ${range} is wrong.`);
    }
    parts = parts[1].split("-");
    if (parts === undefined || parts.length < 1 || parts.length > 2) {
        throw new RangeError(`deserializeRangeHeader: raw range value ${range} is wrong.`);
    }
    const startInclusive = parseInt(parts[0], 10);
    let endInclusive = Infinity;
    if (parts.length > 1 && parts[1] !== "") {
        endInclusive = parseInt(parts[1], 10);
    }
    if (startInclusive > endInclusive) {
        throw new RangeError(`deserializeRangeHeader: raw range value ${range} is wrong.`);
    }
    return [startInclusive, endInclusive];
}
exports.deserializeRangeHeader = deserializeRangeHeader;
/**
 * Deserialize range header into valid page ranges.
 * For example, "bytes=0-1023" will return [0, 1023].
 *
 * Default range value [0, Infinite] will be returned if all parameters not provided.
 *
 * @private
 * @param {string} [rangeHeaderValue]
 * @param {string} [xMsRangeHeaderValue]
 * @returns {([number, number] | undefined)}
 */
function deserializePageBlobRangeHeader(rangeHeaderValue, xMsRangeHeaderValue, force512boundary = true) {
    const ranges = deserializeRangeHeader(rangeHeaderValue, xMsRangeHeaderValue);
    const startInclusive = ranges[0];
    const endInclusive = ranges[1];
    if (force512boundary && startInclusive % 512 !== 0) {
        throw new RangeError(`deserializePageBlobRangeHeader: range start value ${startInclusive} doesn't align with 512 boundary.`);
    }
    if (force512boundary &&
        endInclusive !== Infinity &&
        (endInclusive + 1) % 512 !== 0) {
        throw new RangeError(`deserializePageBlobRangeHeader: range end value ${endInclusive} doesn't align with 512 boundary.`);
    }
    return [startInclusive, endInclusive];
}
exports.deserializePageBlobRangeHeader = deserializePageBlobRangeHeader;
/**
 * Remove double Quotation mark from ListBlob returned Etag, to align with server
 *
 * @param {string} [inputEtag]
 * @returns {string}
 */
function removeQuotationFromListBlobEtag(inputEtag) {
    if (inputEtag === undefined) {
        return inputEtag;
    }
    if (inputEtag[0] === '"' && inputEtag[inputEtag.length - 1] === '"') {
        return inputEtag.substring(1, inputEtag.length - 1);
    }
    return inputEtag;
}
exports.removeQuotationFromListBlobEtag = removeQuotationFromListBlobEtag;
function validateContainerName(requestID, containerName) {
    if (containerName !== "" &&
        (containerName.length < 3 || containerName.length > 63)) {
        throw StorageErrorFactory_1.default.getOutOfRangeName(requestID);
    }
    const reg = new RegExp("^[a-z0-9](?!.*--)[a-z0-9-]{1,61}[a-z0-9]$");
    if (!reg.test(containerName)) {
        throw StorageErrorFactory_1.default.getInvalidResourceName(requestID);
    }
}
exports.validateContainerName = validateContainerName;
//# sourceMappingURL=utils.js.map