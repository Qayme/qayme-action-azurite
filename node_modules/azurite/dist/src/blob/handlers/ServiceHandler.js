"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const BlobStorageContext_1 = tslib_1.__importDefault(require("../context/BlobStorageContext"));
const StorageErrorFactory_1 = tslib_1.__importDefault(require("../errors/StorageErrorFactory"));
const NotImplementedError_1 = tslib_1.__importDefault(require("../errors/NotImplementedError"));
const Models = tslib_1.__importStar(require("../generated/artifacts/models"));
const xml_1 = require("../generated/utils/xml");
const constants_1 = require("../utils/constants");
const BaseHandler_1 = tslib_1.__importDefault(require("./BaseHandler"));
/**
 * ServiceHandler handles Azure Storage Blob service related requests.
 *
 * @export
 * @class ServiceHandler
 * @implements {IHandler}
 */
class ServiceHandler extends BaseHandler_1.default {
    constructor() {
        super(...arguments);
        /**
         * Default service properties.
         *
         * @private
         * @memberof ServiceHandler
         */
        this.defaultServiceProperties = {
            cors: [],
            defaultServiceVersion: constants_1.BLOB_API_VERSION,
            hourMetrics: {
                enabled: false,
                retentionPolicy: {
                    enabled: false
                },
                version: "1.0"
            },
            logging: {
                deleteProperty: true,
                read: true,
                retentionPolicy: {
                    enabled: false
                },
                version: "1.0",
                write: true
            },
            minuteMetrics: {
                enabled: false,
                retentionPolicy: {
                    enabled: false
                },
                version: "1.0"
            },
            staticWebsite: {
                enabled: false
            }
        };
    }
    getUserDelegationKey(keyInfo, options, context) {
        throw new NotImplementedError_1.default(context.contextId);
    }
    submitBatch(body, contentLength, multipartContentType, options, context) {
        throw new NotImplementedError_1.default(context.contextId);
    }
    /**
     * Set blob service properties.
     *
     * @param {Models.StorageServiceProperties} storageServiceProperties
     * @param {Models.ServiceSetPropertiesOptionalParams} options
     * @param {Context} context
     * @returns {Promise<Models.ServiceSetPropertiesResponse>}
     * @memberof ServiceHandler
     */
    async setProperties(storageServiceProperties, options, context) {
        const blobCtx = new BlobStorageContext_1.default(context);
        const accountName = blobCtx.account;
        // TODO: deserializor has a bug that when cors is undefined,
        // it will serialize it to empty array instead of undefined
        const body = blobCtx.request.getBody();
        const parsedBody = await xml_1.parseXML(body || "");
        if (!parsedBody.hasOwnProperty("cors") &&
            !parsedBody.hasOwnProperty("Cors")) {
            storageServiceProperties.cors = undefined;
        }
        // Azure Storage allows allowedHeaders and exposedHeaders to be empty,
        // Azurite will set to empty string for this scenario
        for (const cors of storageServiceProperties.cors || []) {
            cors.allowedHeaders = cors.allowedHeaders || "";
            cors.exposedHeaders = cors.exposedHeaders || "";
        }
        await this.metadataStore.setServiceProperties(context, Object.assign(Object.assign({}, storageServiceProperties), { accountName }));
        const response = {
            requestId: context.contextId,
            statusCode: 202,
            version: constants_1.BLOB_API_VERSION,
            clientRequestId: options.requestId
        };
        return response;
    }
    /**
     * Get blob service properties.
     *
     * @param {Models.ServiceGetPropertiesOptionalParams} options
     * @param {Context} context
     * @returns {Promise<Models.ServiceGetPropertiesResponse>}
     * @memberof ServiceHandler
     */
    async getProperties(options, context) {
        const blobCtx = new BlobStorageContext_1.default(context);
        const accountName = blobCtx.account;
        let properties = await this.metadataStore.getServiceProperties(context, accountName);
        if (!properties) {
            properties = Object.assign(Object.assign({}, this.defaultServiceProperties), { accountName });
        }
        if (properties.cors === undefined) {
            properties.cors = [];
        }
        if (properties.cors === undefined) {
            properties.cors = [];
        }
        if (properties.hourMetrics === undefined) {
            properties.hourMetrics = this.defaultServiceProperties.hourMetrics;
        }
        if (properties.logging === undefined) {
            properties.logging = this.defaultServiceProperties.logging;
        }
        if (properties.minuteMetrics === undefined) {
            properties.minuteMetrics = this.defaultServiceProperties.minuteMetrics;
        }
        if (properties.defaultServiceVersion === undefined) {
            properties.defaultServiceVersion = this.defaultServiceProperties.defaultServiceVersion;
        }
        if (properties.staticWebsite === undefined) {
            properties.staticWebsite = this.defaultServiceProperties.staticWebsite;
        }
        const response = Object.assign(Object.assign({}, properties), { requestId: context.contextId, statusCode: 200, version: constants_1.BLOB_API_VERSION, clientRequestId: options.requestId });
        return response;
    }
    async getStatistics(options, context) {
        if (!context.context.isSecondary) {
            throw StorageErrorFactory_1.default.getInvalidQueryParameterValue(context.contextId);
        }
        const response = {
            statusCode: 200,
            requestId: context.contextId,
            version: constants_1.BLOB_API_VERSION,
            date: context.startTime,
            clientRequestId: options.requestId,
            geoReplication: {
                status: Models.GeoReplicationStatusType.Live,
                lastSyncTime: context.startTime
            }
        };
        return response;
    }
    /**
     * List containers.
     *
     * @param {Models.ServiceListContainersSegmentOptionalParams} options
     * @param {Context} context
     * @returns {Promise<Models.ServiceListContainersSegmentResponse>}
     * @memberof ServiceHandler
     */
    async listContainersSegment(options, context) {
        const blobCtx = new BlobStorageContext_1.default(context);
        const request = blobCtx.request;
        const accountName = blobCtx.account;
        options.maxresults =
            options.maxresults || constants_1.DEFAULT_LIST_CONTAINERS_MAX_RESULTS;
        options.prefix = options.prefix || "";
        const marker = options.marker || "";
        const containers = await this.metadataStore.listContainers(context, accountName, options.prefix, options.maxresults, marker);
        // TODO: Need update list out container lease properties with ContainerHandler.updateLeaseAttributes()
        const serviceEndpoint = `${request.getEndpoint()}/${accountName}`;
        const res = {
            containerItems: containers[0],
            maxResults: options.maxresults,
            nextMarker: `${containers[1] || ""}`,
            prefix: options.prefix,
            serviceEndpoint,
            statusCode: 200,
            requestId: context.contextId,
            version: constants_1.BLOB_API_VERSION,
            clientRequestId: options.requestId
        };
        return res;
    }
    async getAccountInfo(context) {
        const response = {
            statusCode: 200,
            requestId: context.contextId,
            clientRequestId: context.request.getHeader("x-ms-client-request-id"),
            skuName: constants_1.EMULATOR_ACCOUNT_SKUNAME,
            accountKind: constants_1.EMULATOR_ACCOUNT_KIND,
            date: context.startTime,
            version: constants_1.BLOB_API_VERSION
        };
        return response;
    }
    async getAccountInfoWithHead(context) {
        return this.getAccountInfo(context);
    }
}
exports.default = ServiceHandler;
//# sourceMappingURL=ServiceHandler.js.map