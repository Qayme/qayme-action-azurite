"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const stream_1 = require("stream");
const BatchRequestHeaders_1 = tslib_1.__importDefault(require("./BatchRequestHeaders"));
const Models = tslib_1.__importStar(require("../../table/generated/artifacts/models"));
const BatchTableUpdateEntityOptionalParams_1 = tslib_1.__importDefault(require("../../table/batch/BatchTableUpdateEntityOptionalParams"));
const BatchTableDeleteEntityOptionalParams_1 = tslib_1.__importDefault(require("../../table/batch/BatchTableDeleteEntityOptionalParams"));
/*
 * Represents a request in the context of batch operations.
 * ToDo: Requires validation against all operation types
 * Currently several funcitons of the interface are not implemented
 * @export
 * @class BatchRequest
 * @implements {IRequest}
 */
class BatchRequest {
    constructor(batchOperation) {
        this.batchOperation = batchOperation;
        this.headers = new BatchRequestHeaders_1.default(batchOperation.rawHeaders);
        // set default params, due to our processing logic
        this.params = new BatchTableUpdateEntityOptionalParams_1.default();
    }
    // ingests the optional params for a batch request, and sets these
    // based on the type of operation and headers present on an
    // individual request
    ingestOptionalParams(params) {
        var _a, _b, _c;
        this.params = params;
        // need to compare headers to option params and set accordingly
        if (this.getHeader("x-ms-client-request-id") !== undefined) {
            this.params.requestId = this.getHeader("x-ms-client-request-id");
        }
        // Theoretically, this Enum is redundant, and used across all table
        // optional param models, thinking that we only need to use the 1,
        // the code generator is however differentiating across all of them
        // as distinct
        if ((_a = this.getHeader("maxdataserviceversion")) === null || _a === void 0 ? void 0 : _a.includes("3.0")) {
            this.params.dataServiceVersion =
                Models.DataServiceVersion4.ThreeFullStopZero;
        }
        // TableDeleteEntityOptionalParams is the only interface without a body
        // I instantiate the batch class to enable this check and the other
        // interface acrobatics needed for batch processing
        const body = this.getBody();
        if (body != null &&
            body !== "" &&
            !(this.params instanceof BatchTableDeleteEntityOptionalParams_1.default)) {
            this.params.tableEntityProperties = JSON.parse(body);
        }
        // set request timeout
        // https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-table-service-operations
        // set responsePreference
        // set queryOptions
        // https://docs.microsoft.com/en-us/rest/api/storageservices/payload-format-for-table-service-operations
        const options = new Object();
        // format
        // set payload options
        if ((_b = this.getHeader("accept")) === null || _b === void 0 ? void 0 : _b.includes("minimalmeta")) {
            options.format =
                Models.OdataMetadataFormat.Applicationjsonodataminimalmetadata;
        }
        else if ((_c = this.getHeader("accept")) === null || _c === void 0 ? void 0 : _c.includes("fullmeta")) {
            options.format =
                Models.OdataMetadataFormat.Applicationjsonodatafullmetadata;
        }
        else {
            options.format =
                Models.OdataMetadataFormat.Applicationjsonodatanometadata;
        }
        // top
        // select
        // filter
        this.params.queryOptions = options;
    }
    getMethod() {
        if (this.batchOperation.httpMethod != null) {
            return this.batchOperation.httpMethod;
        }
        else {
            throw new Error("httpMethod invalid on batch operation");
        }
    }
    getUrl() {
        // ToDo: is this a valid assumption for the batch API?
        // ToDo: here we also assume https, which is also not true...
        // we need to parse this from the request
        // return `https://${this.accountName}.${this.batchOperation.batchType}.core.windows.net/$batch`;
        // in delete, it seems that we actuall expect the full uri
        if (this.batchOperation.uri != null && this.batchOperation.path != null) {
            return this.batchOperation.uri;
            // this substring is not needed.
            // .substring(
            //   0,
            //   this.batchOperation.uri.length - this.batchOperation.path.length
            // );
        }
        else {
            throw new Error("uri or path null when calling getUrl on BatchRequest");
        }
    }
    getEndpoint() {
        throw new Error("Method not implemented.");
    }
    getPath() {
        if (this.batchOperation.path != null) {
            return this.batchOperation.path;
        }
        else {
            throw new Error("path null  when calling getPath on BatchRequest");
        }
    }
    getBodyStream() {
        if (this.batchOperation.jsonRequestBody != null) {
            return stream_1.Stream.Readable.from(this.batchOperation.jsonRequestBody);
        }
        else {
            throw new Error("body null  when calling getBodyStream on BatchRequest");
        }
    }
    setBody(body) {
        throw new Error("Method not implemented.");
    }
    getBody() {
        if (this.batchOperation.jsonRequestBody != null) {
            return this.batchOperation.jsonRequestBody;
        }
        else {
            throw new Error("body null  when calling getBody on BatchRequest");
        }
    }
    getHeader(field) {
        return this.headers.header(field);
    }
    getHeaders() {
        throw new Error("Method not implemented.");
    }
    getRawHeaders() {
        return this.batchOperation.rawHeaders;
    }
    getQuery(key) {
        var _a, _b, _c, _d, _e;
        switch (key) {
            case "$format":
                return (_a = this.params.queryOptions) === null || _a === void 0 ? void 0 : _a.format;
            case "$top":
                return (_c = (_b = this.params.queryOptions) === null || _b === void 0 ? void 0 : _b.top) === null || _c === void 0 ? void 0 : _c.toLocaleString();
            case "$select":
                return (_d = this.params.queryOptions) === null || _d === void 0 ? void 0 : _d.select;
            case "$filter":
                return (_e = this.params.queryOptions) === null || _e === void 0 ? void 0 : _e.filter;
            default:
                break;
        }
        throw new Error("unknown query options type.");
    }
    getProtocol() {
        if (this.batchOperation.protocol !== null &&
            this.batchOperation.protocol !== undefined) {
            return this.batchOperation.protocol;
        }
        else {
            // try extract protocol
            const protocolMatch = this.getUrl().match(/https?/);
            if (protocolMatch !== null && protocolMatch.length > 0) {
                this.batchOperation.protocol = protocolMatch[0];
                return this.batchOperation.protocol;
            }
            throw new Error("protocol null when calling getProtocol on BatchRequest");
        }
    }
}
exports.default = BatchRequest;
//# sourceMappingURL=BatchRequest.js.map